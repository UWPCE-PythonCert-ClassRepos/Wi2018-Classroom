import os
from enum import  Enum
import datetime
import unicodedata
from config import cfg_dict
import json
import requests
import requests_ntlm
from requests_ntlm import HttpNtlmAuth



class  Format_type(Enum):
    """ Discrete list of SAS variable types """
    Numeric=1
    Char=2

class  Format_val(Enum):
    """ Discrete list of SAS format types"""
    Invalue=1
    Value=2

class Format:
    """An instance of SAS format catalog metadata"""

    def __init__(self,name,desc,is_write,category,category_desc):
        """
        Initialize a format
        :param name: SAS format name
        :param desc: Description
        :param is_write: Indicates if user can extend codelist with custom values
        :param category: CP category that defines intended use
        :param category_desc: Description of the category
        """

        self.name=name
        self.desc=desc
        self.is_extensible=is_write
        self.fmt_type=Format_type.Char
        self.fmt_value=Format_val.Value
        self.category=category
        self.category_desc=category_desc
        self.listvals = []


    def __lt__(self, other):
        """
        Support for sorting by format name
        :param other:
        :return: bool
        """

        return (self.name) < (other.name)

    def __eq__(self, other):
        """
        Support for sorting by format name
        :param other:
        :return: bool
        """

        return (self.name) == (other.name)



    def add_members(self,start,label):
        """
        Add a code/decode value pair to codelist values
        :param start: Code
        :param label: Decode
        :return: None
        """

        self.listvals.append((start, label))

    @staticmethod
    def write_catalog(format_list,study):
        """
        Generates a SAS program file on file share that creates a compiled format library
        :param format_list: Collection of Format
        :param study: (Format) object that contains the details for a clinical trial
        :return: Location of the SAS file
        """

        o_format_list=sorted(format_list)

        fn=study.sas_file

        with open(fn, 'w') as f:
            f.write(f"*{'-'*73}*\n")
            f.write(f"| SAS Formats Catalog for: {study.display_name}\n")
            f.write(f"| Path: {fn}\n")
            f.write(f"| Autogenerated by Candid on: {datetime.datetime.now().strftime('%d-%b-%Y')}\n")
            f.write(f"| {'-' * 10} Post-testing modifications {'-' * 10}\n")
            f.write("|  Date        User        Modification\n|\n")
            f.write(f"*{'-'*73}*;\n")
            f.write("%include 'init.sas';\n\n")

            # delete existing catalogs
            # f.write("proc datasets library=out memtype=catalog;\n\tdelete formats;\nrun;\n\n")

            f.write("proc format library=out;\n")

            for i in o_format_list:

                # Write the invalue statement
                f.write(Format.write_comment(i))

                # Write the invalue statement
                if i.fmt_value==Format_val.Invalue:
                    f.write("\tinvalue")
                    if i.fmt_type==Format_type.Numeric:
                        f.write(f" ${i.name + '_' + i.category}\n")
                    else:
                        f.write(f" {i.name+ '_' + i.category}\n")

                # Write the value statement
                else:
                    if i.fmt_type==Format_type.Char:
                        f.write(f"\tvalue ${i.name + '_' + i.category}\n")
                    else:
                        f.write(f"\tvalue {i.name + '_' + i.category}\n")

                # Loop for each member of format catalog
                for j in i.listvals:
                    # start
                    if i.fmt_type==Format_type.Numeric:
                        f.write(f"\t\t{remove_cc(j[0])} = ")
                    else:
                        f.write(f"\t\t\"{remove_cc(j[0])}\" = ")
                    # label
                    if i.fmt_value == Format_val.Invalue:
                        f.write(f"{remove_cc(j[1])}\n")
                    else:
                        f.write(f'"{remove_cc(j[1])}"\n')
                f.write("\t\t;\n")
            f.write("run;")

        return fn


    @staticmethod
    def write_comment(fmt):
        """
        Writes the comment blocks in the SAS program file for each format
        :param fmt: (Format)object
        :return: String containing newline at 65th position for wrapping
        """

        fit_txt=[fmt.desc[i:i+65] for i in range(0, len(fmt.desc), 65)]

        com_txt=[]
        com_txt.append(f"\t*{'-' * 68}*")
        com_txt.append(f"\t|\tFormat: {fmt.name + '_' + fmt.category}\n\t|\tExtensible:{fmt.is_extensible}")
        com_txt.append(f"\t|\tUsage: {fmt.category_desc}")
        com_txt.append(f"\t|\tDescription: ")
        [com_txt.append(f"\t|\t {i}") for i in fit_txt]
        com_txt.append(f"\t*{'-' * 68}*;\n")

        return "\n".join(com_txt)



class Parse_Format():
    """Class that provides functionity to read and format the data from the API"""

    def __init__(self):
        """
        Initialize instance of class
        """
        self.analysis=''
        self.terms=''
        self.path=''

    def read_analysis(self,id):
        """
        Parse data returned from Analysis API
        :param id: Unique identifier in Candid application
        :return: n/a
        """
        raw=requests.get(cfg_dict['analysis'] + id, auth=HttpNtlmAuth(cfg_dict['user'], cfg_dict['pass']))
        self.analysis=json.loads(raw.text)

        raw = self.analysis['directory'] + cfg_dict['format_loc']
        norm = os.path.normpath(raw)
        if os.path.exists(norm):
            self.path=norm


    def read_terms(self,id):
        """
        Parse data returned from the ControlledTerminatory API
        :param id:  Unique identifier in Candid application
        :return: None
        """

        raw = requests.get(cfg_dict['analysis'] + id + cfg_dict['formats'],auth=HttpNtlmAuth(cfg_dict['user'], cfg_dict['pass']))
        self.terms= json.loads(raw.text)

    @property
    def display_name(self):
        """
        Display name property
        :return: The common name for the analysis
        """

        return self.analysis['displayName']

    @property
    def sas_file(self):
        """
        SAS program file name property
        :return: Path and name for the SAS program file
        """

        return  os.path.normpath(self.path +'\\'+ cfg_dict['format_pgm'])

def remove_cc(s):
    """
    Utility to remove control characters from the values returned from API
    :param s: String
    :return:  The input string without control characters
    """

    return "".join(ch for ch in s if unicodedata.category(ch)[0]!="C")

